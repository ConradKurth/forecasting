// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: order_line_items.sql

package core

import (
	"context"

	"github.com/ConradKurth/forecasting/backend/pkg/id"
	"github.com/jackc/pgx/v5/pgtype"
)

const createOrderLineItem = `-- name: CreateOrderLineItem :one
INSERT INTO order_line_items (id, order_id, external_id, product_id, variant_id, inventory_item_id, quantity, price)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, order_id, external_id, product_id, variant_id, inventory_item_id, quantity, price
`

type CreateOrderLineItemParams struct {
	ID              id.ID[id.OrderLineItem]  `json:"id"`
	OrderID         id.ID[id.Order]          `json:"order_id"`
	ExternalID      pgtype.Text              `json:"external_id"`
	ProductID       id.ID[id.Product]        `json:"product_id"`
	VariantID       id.ID[id.ProductVariant] `json:"variant_id"`
	InventoryItemID id.ID[id.InventoryItem]  `json:"inventory_item_id"`
	Quantity        int32                    `json:"quantity"`
	Price           pgtype.Numeric           `json:"price"`
}

func (q *Queries) CreateOrderLineItem(ctx context.Context, arg CreateOrderLineItemParams) (OrderLineItem, error) {
	row := q.db.QueryRow(ctx, createOrderLineItem,
		arg.ID,
		arg.OrderID,
		arg.ExternalID,
		arg.ProductID,
		arg.VariantID,
		arg.InventoryItemID,
		arg.Quantity,
		arg.Price,
	)
	var i OrderLineItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ExternalID,
		&i.ProductID,
		&i.VariantID,
		&i.InventoryItemID,
		&i.Quantity,
		&i.Price,
	)
	return i, err
}

const getOrderLineItemByID = `-- name: GetOrderLineItemByID :one
SELECT id, order_id, external_id, product_id, variant_id, inventory_item_id, quantity, price
FROM order_line_items
WHERE id = $1
`

func (q *Queries) GetOrderLineItemByID(ctx context.Context, argID id.ID[id.OrderLineItem]) (OrderLineItem, error) {
	row := q.db.QueryRow(ctx, getOrderLineItemByID, argID)
	var i OrderLineItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ExternalID,
		&i.ProductID,
		&i.VariantID,
		&i.InventoryItemID,
		&i.Quantity,
		&i.Price,
	)
	return i, err
}

const getOrderLineItemsByOrderID = `-- name: GetOrderLineItemsByOrderID :many
SELECT id, order_id, external_id, product_id, variant_id, inventory_item_id, quantity, price
FROM order_line_items
WHERE order_id = $1
ORDER BY id
`

func (q *Queries) GetOrderLineItemsByOrderID(ctx context.Context, orderID id.ID[id.Order]) ([]OrderLineItem, error) {
	rows, err := q.db.Query(ctx, getOrderLineItemsByOrderID, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OrderLineItem{}
	for rows.Next() {
		var i OrderLineItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.ExternalID,
			&i.ProductID,
			&i.VariantID,
			&i.InventoryItemID,
			&i.Quantity,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertOrderLineItem = `-- name: UpsertOrderLineItem :one
INSERT INTO order_line_items (id, order_id, external_id, product_id, variant_id, inventory_item_id, quantity, price)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT (order_id, external_id)
DO UPDATE SET
    product_id = EXCLUDED.product_id,
    variant_id = EXCLUDED.variant_id,
    inventory_item_id = EXCLUDED.inventory_item_id,
    quantity = EXCLUDED.quantity,
    price = EXCLUDED.price
RETURNING id, order_id, external_id, product_id, variant_id, inventory_item_id, quantity, price
`

type UpsertOrderLineItemParams struct {
	ID              id.ID[id.OrderLineItem]  `json:"id"`
	OrderID         id.ID[id.Order]          `json:"order_id"`
	ExternalID      pgtype.Text              `json:"external_id"`
	ProductID       id.ID[id.Product]        `json:"product_id"`
	VariantID       id.ID[id.ProductVariant] `json:"variant_id"`
	InventoryItemID id.ID[id.InventoryItem]  `json:"inventory_item_id"`
	Quantity        int32                    `json:"quantity"`
	Price           pgtype.Numeric           `json:"price"`
}

func (q *Queries) UpsertOrderLineItem(ctx context.Context, arg UpsertOrderLineItemParams) (OrderLineItem, error) {
	row := q.db.QueryRow(ctx, upsertOrderLineItem,
		arg.ID,
		arg.OrderID,
		arg.ExternalID,
		arg.ProductID,
		arg.VariantID,
		arg.InventoryItemID,
		arg.Quantity,
		arg.Price,
	)
	var i OrderLineItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.ExternalID,
		&i.ProductID,
		&i.VariantID,
		&i.InventoryItemID,
		&i.Quantity,
		&i.Price,
	)
	return i, err
}
