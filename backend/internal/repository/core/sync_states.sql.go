// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: sync_states.sql

package core

import (
	"context"

	"github.com/ConradKurth/forecasting/backend/pkg/id"
	"github.com/jackc/pgx/v5/pgtype"
)

const createSyncState = `-- name: CreateSyncState :one
INSERT INTO sync_states (id, integration_id, entity_type, last_synced_at, sync_status, error_message)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, integration_id, entity_type, last_synced_at, sync_status, error_message
`

type CreateSyncStateParams struct {
	ID            id.ID[id.SyncState]           `json:"id"`
	IntegrationID id.ID[id.PlatformIntegration] `json:"integration_id"`
	EntityType    EntityType                    `json:"entity_type"`
	LastSyncedAt  pgtype.Timestamp              `json:"last_synced_at"`
	SyncStatus    SyncStatus                    `json:"sync_status"`
	ErrorMessage  pgtype.Text                   `json:"error_message"`
}

func (q *Queries) CreateSyncState(ctx context.Context, arg CreateSyncStateParams) (SyncState, error) {
	row := q.db.QueryRow(ctx, createSyncState,
		arg.ID,
		arg.IntegrationID,
		arg.EntityType,
		arg.LastSyncedAt,
		arg.SyncStatus,
		arg.ErrorMessage,
	)
	var i SyncState
	err := row.Scan(
		&i.ID,
		&i.IntegrationID,
		&i.EntityType,
		&i.LastSyncedAt,
		&i.SyncStatus,
		&i.ErrorMessage,
	)
	return i, err
}

const deleteSyncState = `-- name: DeleteSyncState :exec
DELETE FROM sync_states WHERE integration_id = $1 AND entity_type = $2
`

type DeleteSyncStateParams struct {
	IntegrationID id.ID[id.PlatformIntegration] `json:"integration_id"`
	EntityType    EntityType                    `json:"entity_type"`
}

func (q *Queries) DeleteSyncState(ctx context.Context, arg DeleteSyncStateParams) error {
	_, err := q.db.Exec(ctx, deleteSyncState, arg.IntegrationID, arg.EntityType)
	return err
}

const getSyncState = `-- name: GetSyncState :one
SELECT id, integration_id, entity_type, last_synced_at, sync_status, error_message
FROM sync_states
WHERE integration_id = $1 AND entity_type = $2
`

type GetSyncStateParams struct {
	IntegrationID id.ID[id.PlatformIntegration] `json:"integration_id"`
	EntityType    EntityType                    `json:"entity_type"`
}

func (q *Queries) GetSyncState(ctx context.Context, arg GetSyncStateParams) (SyncState, error) {
	row := q.db.QueryRow(ctx, getSyncState, arg.IntegrationID, arg.EntityType)
	var i SyncState
	err := row.Scan(
		&i.ID,
		&i.IntegrationID,
		&i.EntityType,
		&i.LastSyncedAt,
		&i.SyncStatus,
		&i.ErrorMessage,
	)
	return i, err
}

const getSyncStatesByIntegrationID = `-- name: GetSyncStatesByIntegrationID :many
SELECT id, integration_id, entity_type, last_synced_at, sync_status, error_message
FROM sync_states
WHERE integration_id = $1
ORDER BY last_synced_at DESC
`

func (q *Queries) GetSyncStatesByIntegrationID(ctx context.Context, integrationID id.ID[id.PlatformIntegration]) ([]SyncState, error) {
	rows, err := q.db.Query(ctx, getSyncStatesByIntegrationID, integrationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SyncState{}
	for rows.Next() {
		var i SyncState
		if err := rows.Scan(
			&i.ID,
			&i.IntegrationID,
			&i.EntityType,
			&i.LastSyncedAt,
			&i.SyncStatus,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSyncState = `-- name: UpdateSyncState :one
UPDATE sync_states
SET last_synced_at = $3, sync_status = $4, error_message = $5
WHERE integration_id = $1 AND entity_type = $2
RETURNING id, integration_id, entity_type, last_synced_at, sync_status, error_message
`

type UpdateSyncStateParams struct {
	IntegrationID id.ID[id.PlatformIntegration] `json:"integration_id"`
	EntityType    EntityType                    `json:"entity_type"`
	LastSyncedAt  pgtype.Timestamp              `json:"last_synced_at"`
	SyncStatus    SyncStatus                    `json:"sync_status"`
	ErrorMessage  pgtype.Text                   `json:"error_message"`
}

func (q *Queries) UpdateSyncState(ctx context.Context, arg UpdateSyncStateParams) (SyncState, error) {
	row := q.db.QueryRow(ctx, updateSyncState,
		arg.IntegrationID,
		arg.EntityType,
		arg.LastSyncedAt,
		arg.SyncStatus,
		arg.ErrorMessage,
	)
	var i SyncState
	err := row.Scan(
		&i.ID,
		&i.IntegrationID,
		&i.EntityType,
		&i.LastSyncedAt,
		&i.SyncStatus,
		&i.ErrorMessage,
	)
	return i, err
}

const upsertSyncState = `-- name: UpsertSyncState :one
INSERT INTO sync_states (id, integration_id, entity_type, last_synced_at, sync_status, error_message)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (integration_id, entity_type)
DO UPDATE SET
    last_synced_at = EXCLUDED.last_synced_at,
    sync_status = EXCLUDED.sync_status,
    error_message = EXCLUDED.error_message
RETURNING id, integration_id, entity_type, last_synced_at, sync_status, error_message
`

type UpsertSyncStateParams struct {
	ID            id.ID[id.SyncState]           `json:"id"`
	IntegrationID id.ID[id.PlatformIntegration] `json:"integration_id"`
	EntityType    EntityType                    `json:"entity_type"`
	LastSyncedAt  pgtype.Timestamp              `json:"last_synced_at"`
	SyncStatus    SyncStatus                    `json:"sync_status"`
	ErrorMessage  pgtype.Text                   `json:"error_message"`
}

func (q *Queries) UpsertSyncState(ctx context.Context, arg UpsertSyncStateParams) (SyncState, error) {
	row := q.db.QueryRow(ctx, upsertSyncState,
		arg.ID,
		arg.IntegrationID,
		arg.EntityType,
		arg.LastSyncedAt,
		arg.SyncStatus,
		arg.ErrorMessage,
	)
	var i SyncState
	err := row.Scan(
		&i.ID,
		&i.IntegrationID,
		&i.EntityType,
		&i.LastSyncedAt,
		&i.SyncStatus,
		&i.ErrorMessage,
	)
	return i, err
}
