// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: product_variants.sql

package core

import (
	"context"

	"github.com/ConradKurth/forecasting/backend/pkg/id"
	"github.com/jackc/pgx/v5/pgtype"
)

const createProductVariant = `-- name: CreateProductVariant :one
INSERT INTO product_variants (id, product_id, external_id, sku, price, inventory_item_id, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
RETURNING id, product_id, external_id, sku, price, inventory_item_id, created_at, updated_at
`

type CreateProductVariantParams struct {
	ID              id.ID[id.ProductVariant] `json:"id"`
	ProductID       id.ID[id.Product]        `json:"product_id"`
	ExternalID      pgtype.Text              `json:"external_id"`
	Sku             pgtype.Text              `json:"sku"`
	Price           pgtype.Numeric           `json:"price"`
	InventoryItemID pgtype.Text              `json:"inventory_item_id"`
}

func (q *Queries) CreateProductVariant(ctx context.Context, arg CreateProductVariantParams) (ProductVariant, error) {
	row := q.db.QueryRow(ctx, createProductVariant,
		arg.ID,
		arg.ProductID,
		arg.ExternalID,
		arg.Sku,
		arg.Price,
		arg.InventoryItemID,
	)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ExternalID,
		&i.Sku,
		&i.Price,
		&i.InventoryItemID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductVariantByExternalID = `-- name: GetProductVariantByExternalID :one
SELECT pv.id, pv.product_id, pv.external_id, pv.sku, pv.price, pv.inventory_item_id, pv.created_at, pv.updated_at
FROM product_variants pv
JOIN products p ON pv.product_id = p.id
WHERE p.integration_id = $1 AND pv.external_id = $2
`

type GetProductVariantByExternalIDParams struct {
	IntegrationID id.ID[id.PlatformIntegration] `json:"integration_id"`
	ExternalID    pgtype.Text                   `json:"external_id"`
}

func (q *Queries) GetProductVariantByExternalID(ctx context.Context, arg GetProductVariantByExternalIDParams) (ProductVariant, error) {
	row := q.db.QueryRow(ctx, getProductVariantByExternalID, arg.IntegrationID, arg.ExternalID)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ExternalID,
		&i.Sku,
		&i.Price,
		&i.InventoryItemID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductVariantByID = `-- name: GetProductVariantByID :one
SELECT id, product_id, external_id, sku, price, inventory_item_id, created_at, updated_at
FROM product_variants
WHERE id = $1
`

func (q *Queries) GetProductVariantByID(ctx context.Context, argID id.ID[id.ProductVariant]) (ProductVariant, error) {
	row := q.db.QueryRow(ctx, getProductVariantByID, argID)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ExternalID,
		&i.Sku,
		&i.Price,
		&i.InventoryItemID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductVariantsByIntegrationID = `-- name: GetProductVariantsByIntegrationID :many
SELECT pv.id, pv.product_id, pv.external_id, pv.sku, pv.price, pv.inventory_item_id, pv.created_at, pv.updated_at
FROM product_variants pv
JOIN products p ON pv.product_id = p.id
WHERE p.integration_id = $1
ORDER BY pv.created_at DESC
LIMIT $2 OFFSET $3
`

type GetProductVariantsByIntegrationIDParams struct {
	IntegrationID id.ID[id.PlatformIntegration] `json:"integration_id"`
	Limit         int32                         `json:"limit"`
	Offset        int32                         `json:"offset"`
}

func (q *Queries) GetProductVariantsByIntegrationID(ctx context.Context, arg GetProductVariantsByIntegrationIDParams) ([]ProductVariant, error) {
	rows, err := q.db.Query(ctx, getProductVariantsByIntegrationID, arg.IntegrationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductVariant{}
	for rows.Next() {
		var i ProductVariant
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ExternalID,
			&i.Sku,
			&i.Price,
			&i.InventoryItemID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductVariantsByProductID = `-- name: GetProductVariantsByProductID :many
SELECT id, product_id, external_id, sku, price, inventory_item_id, created_at, updated_at
FROM product_variants
WHERE product_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetProductVariantsByProductID(ctx context.Context, productID id.ID[id.Product]) ([]ProductVariant, error) {
	rows, err := q.db.Query(ctx, getProductVariantsByProductID, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductVariant{}
	for rows.Next() {
		var i ProductVariant
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ExternalID,
			&i.Sku,
			&i.Price,
			&i.InventoryItemID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertProductVariant = `-- name: UpsertProductVariant :one
INSERT INTO product_variants (id, product_id, external_id, sku, price, inventory_item_id, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
ON CONFLICT (external_id)
DO UPDATE SET
    sku = EXCLUDED.sku,
    price = EXCLUDED.price,
    inventory_item_id = EXCLUDED.inventory_item_id,
    updated_at = NOW()
RETURNING id, product_id, external_id, sku, price, inventory_item_id, created_at, updated_at
`

type UpsertProductVariantParams struct {
	ID              id.ID[id.ProductVariant] `json:"id"`
	ProductID       id.ID[id.Product]        `json:"product_id"`
	ExternalID      pgtype.Text              `json:"external_id"`
	Sku             pgtype.Text              `json:"sku"`
	Price           pgtype.Numeric           `json:"price"`
	InventoryItemID pgtype.Text              `json:"inventory_item_id"`
}

func (q *Queries) UpsertProductVariant(ctx context.Context, arg UpsertProductVariantParams) (ProductVariant, error) {
	row := q.db.QueryRow(ctx, upsertProductVariant,
		arg.ID,
		arg.ProductID,
		arg.ExternalID,
		arg.Sku,
		arg.Price,
		arg.InventoryItemID,
	)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ExternalID,
		&i.Sku,
		&i.Price,
		&i.InventoryItemID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
