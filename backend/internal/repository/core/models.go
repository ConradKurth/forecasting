// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package core

import (
	"database/sql/driver"
	"fmt"

	"github.com/ConradKurth/forecasting/backend/pkg/id"
	"github.com/jackc/pgx/v5/pgtype"
)

type EntityType string

const (
	EntityTypeProducts  EntityType = "products"
	EntityTypeOrders    EntityType = "orders"
	EntityTypeInventory EntityType = "inventory"
	EntityTypeLocations EntityType = "locations"
	EntityTypeFullSync  EntityType = "full_sync"
)

func (e *EntityType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EntityType(s)
	case string:
		*e = EntityType(s)
	default:
		return fmt.Errorf("unsupported scan type for EntityType: %T", src)
	}
	return nil
}

type NullEntityType struct {
	EntityType EntityType `json:"entity_type"`
	Valid      bool       `json:"valid"` // Valid is true if EntityType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEntityType) Scan(value interface{}) error {
	if value == nil {
		ns.EntityType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EntityType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEntityType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EntityType), nil
}

type FinancialStatus string

const (
	FinancialStatusPending           FinancialStatus = "pending"
	FinancialStatusAuthorized        FinancialStatus = "authorized"
	FinancialStatusPartiallyPaid     FinancialStatus = "partially_paid"
	FinancialStatusPaid              FinancialStatus = "paid"
	FinancialStatusPartiallyRefunded FinancialStatus = "partially_refunded"
	FinancialStatusRefunded          FinancialStatus = "refunded"
	FinancialStatusVoided            FinancialStatus = "voided"
)

func (e *FinancialStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = FinancialStatus(s)
	case string:
		*e = FinancialStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for FinancialStatus: %T", src)
	}
	return nil
}

type NullFinancialStatus struct {
	FinancialStatus FinancialStatus `json:"financial_status"`
	Valid           bool            `json:"valid"` // Valid is true if FinancialStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullFinancialStatus) Scan(value interface{}) error {
	if value == nil {
		ns.FinancialStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.FinancialStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullFinancialStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.FinancialStatus), nil
}

type FulfillmentStatus string

const (
	FulfillmentStatusFulfilled FulfillmentStatus = "fulfilled"
	FulfillmentStatusNull      FulfillmentStatus = "null"
	FulfillmentStatusPartial   FulfillmentStatus = "partial"
	FulfillmentStatusRestocked FulfillmentStatus = "restocked"
)

func (e *FulfillmentStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = FulfillmentStatus(s)
	case string:
		*e = FulfillmentStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for FulfillmentStatus: %T", src)
	}
	return nil
}

type NullFulfillmentStatus struct {
	FulfillmentStatus FulfillmentStatus `json:"fulfillment_status"`
	Valid             bool              `json:"valid"` // Valid is true if FulfillmentStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullFulfillmentStatus) Scan(value interface{}) error {
	if value == nil {
		ns.FulfillmentStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.FulfillmentStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullFulfillmentStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.FulfillmentStatus), nil
}

type PlatformType string

const (
	PlatformTypeShopify     PlatformType = "shopify"
	PlatformTypeWoocommerce PlatformType = "woocommerce"
	PlatformTypeBigcommerce PlatformType = "bigcommerce"
	PlatformTypeSquare      PlatformType = "square"
	PlatformTypeMagento     PlatformType = "magento"
)

func (e *PlatformType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PlatformType(s)
	case string:
		*e = PlatformType(s)
	default:
		return fmt.Errorf("unsupported scan type for PlatformType: %T", src)
	}
	return nil
}

type NullPlatformType struct {
	PlatformType PlatformType `json:"platform_type"`
	Valid        bool         `json:"valid"` // Valid is true if PlatformType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPlatformType) Scan(value interface{}) error {
	if value == nil {
		ns.PlatformType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PlatformType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPlatformType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PlatformType), nil
}

type ProductStatus string

const (
	ProductStatusActive   ProductStatus = "active"
	ProductStatusArchived ProductStatus = "archived"
	ProductStatusDraft    ProductStatus = "draft"
)

func (e *ProductStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ProductStatus(s)
	case string:
		*e = ProductStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ProductStatus: %T", src)
	}
	return nil
}

type NullProductStatus struct {
	ProductStatus ProductStatus `json:"product_status"`
	Valid         bool          `json:"valid"` // Valid is true if ProductStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullProductStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ProductStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ProductStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullProductStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ProductStatus), nil
}

type SyncStatus string

const (
	SyncStatusPending    SyncStatus = "pending"
	SyncStatusInProgress SyncStatus = "in_progress"
	SyncStatusCompleted  SyncStatus = "completed"
	SyncStatusFailed     SyncStatus = "failed"
)

func (e *SyncStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SyncStatus(s)
	case string:
		*e = SyncStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for SyncStatus: %T", src)
	}
	return nil
}

type NullSyncStatus struct {
	SyncStatus SyncStatus `json:"sync_status"`
	Valid      bool       `json:"valid"` // Valid is true if SyncStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSyncStatus) Scan(value interface{}) error {
	if value == nil {
		ns.SyncStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SyncStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSyncStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SyncStatus), nil
}

type InventoryItem struct {
	ID            id.ID[id.InventoryItem]       `json:"id"`
	IntegrationID id.ID[id.PlatformIntegration] `json:"integration_id"`
	ExternalID    pgtype.Text                   `json:"external_id"`
	Sku           pgtype.Text                   `json:"sku"`
	Tracked       pgtype.Bool                   `json:"tracked"`
	Cost          pgtype.Numeric                `json:"cost"`
	CreatedAt     pgtype.Timestamp              `json:"created_at"`
	UpdatedAt     pgtype.Timestamp              `json:"updated_at"`
}

type InventoryLevel struct {
	ID              id.ID[id.InventoryLevel] `json:"id"`
	InventoryItemID id.ID[id.InventoryItem]  `json:"inventory_item_id"`
	LocationID      id.ID[id.Location]       `json:"location_id"`
	Available       pgtype.Int4              `json:"available"`
	UpdatedAt       pgtype.Timestamp         `json:"updated_at"`
}

type Location struct {
	ID            id.ID[id.Location]            `json:"id"`
	IntegrationID id.ID[id.PlatformIntegration] `json:"integration_id"`
	ExternalID    pgtype.Text                   `json:"external_id"`
	Name          string                        `json:"name"`
	Address       pgtype.Text                   `json:"address"`
	Country       pgtype.Text                   `json:"country"`
	Province      pgtype.Text                   `json:"province"`
	IsActive      pgtype.Bool                   `json:"is_active"`
	CreatedAt     pgtype.Timestamp              `json:"created_at"`
	UpdatedAt     pgtype.Timestamp              `json:"updated_at"`
}

type Order struct {
	ID                id.ID[id.Order]               `json:"id"`
	IntegrationID     id.ID[id.PlatformIntegration] `json:"integration_id"`
	ExternalID        pgtype.Text                   `json:"external_id"`
	CreatedAt         pgtype.Timestamp              `json:"created_at"`
	FinancialStatus   FinancialStatus               `json:"financial_status"`
	FulfillmentStatus FulfillmentStatus             `json:"fulfillment_status"`
	TotalPrice        pgtype.Numeric                `json:"total_price"`
	CancelledAt       pgtype.Timestamp              `json:"cancelled_at"`
}

type OrderLineItem struct {
	ID              id.ID[id.OrderLineItem]  `json:"id"`
	OrderID         id.ID[id.Order]          `json:"order_id"`
	ExternalID      pgtype.Text              `json:"external_id"`
	ProductID       id.ID[id.Product]        `json:"product_id"`
	VariantID       id.ID[id.ProductVariant] `json:"variant_id"`
	InventoryItemID id.ID[id.InventoryItem]  `json:"inventory_item_id"`
	Quantity        int32                    `json:"quantity"`
	Price           pgtype.Numeric           `json:"price"`
}

type PlatformIntegration struct {
	ID             id.ID[id.PlatformIntegration] `json:"id"`
	ShopID         id.ID[id.ShopifyStore]        `json:"shop_id"`
	PlatformType   PlatformType                  `json:"platform_type"`
	PlatformShopID string                        `json:"platform_shop_id"`
	IsActive       pgtype.Bool                   `json:"is_active"`
	CreatedAt      pgtype.Timestamp              `json:"created_at"`
	UpdatedAt      pgtype.Timestamp              `json:"updated_at"`
}

type Product struct {
	ID            id.ID[id.Product]             `json:"id"`
	IntegrationID id.ID[id.PlatformIntegration] `json:"integration_id"`
	ExternalID    pgtype.Text                   `json:"external_id"`
	Title         string                        `json:"title"`
	Handle        string                        `json:"handle"`
	ProductType   pgtype.Text                   `json:"product_type"`
	Status        ProductStatus                 `json:"status"`
	CreatedAt     pgtype.Timestamp              `json:"created_at"`
	UpdatedAt     pgtype.Timestamp              `json:"updated_at"`
}

type ProductVariant struct {
	ID              id.ID[id.ProductVariant] `json:"id"`
	ProductID       id.ID[id.Product]        `json:"product_id"`
	ExternalID      pgtype.Text              `json:"external_id"`
	Sku             pgtype.Text              `json:"sku"`
	Price           pgtype.Numeric           `json:"price"`
	InventoryItemID pgtype.Text              `json:"inventory_item_id"`
	CreatedAt       pgtype.Timestamp         `json:"created_at"`
	UpdatedAt       pgtype.Timestamp         `json:"updated_at"`
}

type ShopifyStore struct {
	ID         string           `json:"id"`
	ShopDomain string           `json:"shop_domain"`
	ShopName   pgtype.Text      `json:"shop_name"`
	Timezone   pgtype.Text      `json:"timezone"`
	Currency   pgtype.Text      `json:"currency"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	UpdatedAt  pgtype.Timestamp `json:"updated_at"`
}

type ShopifyUser struct {
	ID             string           `json:"id"`
	UserID         string           `json:"user_id"`
	ShopifyStoreID string           `json:"shopify_store_id"`
	AccessToken    string           `json:"access_token"`
	Scope          string           `json:"scope"`
	ExpiresAt      pgtype.Timestamp `json:"expires_at"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
}

type SyncState struct {
	ID            id.ID[id.SyncState]           `json:"id"`
	IntegrationID id.ID[id.PlatformIntegration] `json:"integration_id"`
	EntityType    EntityType                    `json:"entity_type"`
	LastSyncedAt  pgtype.Timestamp              `json:"last_synced_at"`
	SyncStatus    SyncStatus                    `json:"sync_status"`
	ErrorMessage  pgtype.Text                   `json:"error_message"`
}

type User struct {
	ID        string           `json:"id"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}
