// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: products.sql

package core

import (
	"context"

	"github.com/ConradKurth/forecasting/backend/pkg/id"
	"github.com/jackc/pgx/v5/pgtype"
)

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (id, integration_id, external_id, title, handle, product_type, status, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, NOW(), NOW())
RETURNING id, integration_id, external_id, title, handle, product_type, status, created_at, updated_at
`

type CreateProductParams struct {
	ID            id.ID[id.Product]             `json:"id"`
	IntegrationID id.ID[id.PlatformIntegration] `json:"integration_id"`
	ExternalID    pgtype.Text                   `json:"external_id"`
	Title         string                        `json:"title"`
	Handle        string                        `json:"handle"`
	ProductType   pgtype.Text                   `json:"product_type"`
	Status        ProductStatus                 `json:"status"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.ID,
		arg.IntegrationID,
		arg.ExternalID,
		arg.Title,
		arg.Handle,
		arg.ProductType,
		arg.Status,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.IntegrationID,
		&i.ExternalID,
		&i.Title,
		&i.Handle,
		&i.ProductType,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products WHERE id = $1 AND integration_id = $2
`

type DeleteProductParams struct {
	ID            id.ID[id.Product]             `json:"id"`
	IntegrationID id.ID[id.PlatformIntegration] `json:"integration_id"`
}

func (q *Queries) DeleteProduct(ctx context.Context, arg DeleteProductParams) error {
	_, err := q.db.Exec(ctx, deleteProduct, arg.ID, arg.IntegrationID)
	return err
}

const getProductByExternalID = `-- name: GetProductByExternalID :one
SELECT id, integration_id, external_id, title, handle, product_type, status, created_at, updated_at
FROM products
WHERE integration_id = $1 AND external_id = $2
`

type GetProductByExternalIDParams struct {
	IntegrationID id.ID[id.PlatformIntegration] `json:"integration_id"`
	ExternalID    pgtype.Text                   `json:"external_id"`
}

func (q *Queries) GetProductByExternalID(ctx context.Context, arg GetProductByExternalIDParams) (Product, error) {
	row := q.db.QueryRow(ctx, getProductByExternalID, arg.IntegrationID, arg.ExternalID)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.IntegrationID,
		&i.ExternalID,
		&i.Title,
		&i.Handle,
		&i.ProductType,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductByHandle = `-- name: GetProductByHandle :one
SELECT id, integration_id, external_id, title, handle, product_type, status, created_at, updated_at
FROM products
WHERE integration_id = $1 AND handle = $2
`

type GetProductByHandleParams struct {
	IntegrationID id.ID[id.PlatformIntegration] `json:"integration_id"`
	Handle        string                        `json:"handle"`
}

func (q *Queries) GetProductByHandle(ctx context.Context, arg GetProductByHandleParams) (Product, error) {
	row := q.db.QueryRow(ctx, getProductByHandle, arg.IntegrationID, arg.Handle)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.IntegrationID,
		&i.ExternalID,
		&i.Title,
		&i.Handle,
		&i.ProductType,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductByID = `-- name: GetProductByID :one
SELECT id, integration_id, external_id, title, handle, product_type, status, created_at, updated_at
FROM products
WHERE id = $1
`

func (q *Queries) GetProductByID(ctx context.Context, argID id.ID[id.Product]) (Product, error) {
	row := q.db.QueryRow(ctx, getProductByID, argID)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.IntegrationID,
		&i.ExternalID,
		&i.Title,
		&i.Handle,
		&i.ProductType,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductsByIntegrationID = `-- name: GetProductsByIntegrationID :many
SELECT id, integration_id, external_id, title, handle, product_type, status, created_at, updated_at
FROM products
WHERE integration_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetProductsByIntegrationIDParams struct {
	IntegrationID id.ID[id.PlatformIntegration] `json:"integration_id"`
	Limit         int32                         `json:"limit"`
	Offset        int32                         `json:"offset"`
}

func (q *Queries) GetProductsByIntegrationID(ctx context.Context, arg GetProductsByIntegrationIDParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, getProductsByIntegrationID, arg.IntegrationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.IntegrationID,
			&i.ExternalID,
			&i.Title,
			&i.Handle,
			&i.ProductType,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET title = $3, handle = $4, product_type = $5, status = $6, updated_at = NOW()
WHERE id = $1 AND integration_id = $2
RETURNING id, integration_id, external_id, title, handle, product_type, status, created_at, updated_at
`

type UpdateProductParams struct {
	ID            id.ID[id.Product]             `json:"id"`
	IntegrationID id.ID[id.PlatformIntegration] `json:"integration_id"`
	Title         string                        `json:"title"`
	Handle        string                        `json:"handle"`
	ProductType   pgtype.Text                   `json:"product_type"`
	Status        ProductStatus                 `json:"status"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.ID,
		arg.IntegrationID,
		arg.Title,
		arg.Handle,
		arg.ProductType,
		arg.Status,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.IntegrationID,
		&i.ExternalID,
		&i.Title,
		&i.Handle,
		&i.ProductType,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertProduct = `-- name: UpsertProduct :one
INSERT INTO products (id, integration_id, external_id, title, handle, product_type, status, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, NOW(), NOW())
ON CONFLICT (integration_id, handle)
DO UPDATE SET
    external_id = EXCLUDED.external_id,
    title = EXCLUDED.title,
    product_type = EXCLUDED.product_type,
    status = EXCLUDED.status,
    updated_at = NOW()
RETURNING id, integration_id, external_id, title, handle, product_type, status, created_at, updated_at
`

type UpsertProductParams struct {
	ID            id.ID[id.Product]             `json:"id"`
	IntegrationID id.ID[id.PlatformIntegration] `json:"integration_id"`
	ExternalID    pgtype.Text                   `json:"external_id"`
	Title         string                        `json:"title"`
	Handle        string                        `json:"handle"`
	ProductType   pgtype.Text                   `json:"product_type"`
	Status        ProductStatus                 `json:"status"`
}

func (q *Queries) UpsertProduct(ctx context.Context, arg UpsertProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, upsertProduct,
		arg.ID,
		arg.IntegrationID,
		arg.ExternalID,
		arg.Title,
		arg.Handle,
		arg.ProductType,
		arg.Status,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.IntegrationID,
		&i.ExternalID,
		&i.Title,
		&i.Handle,
		&i.ProductType,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
