// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: batch.go

package core

import (
	"context"
	"errors"

	"github.com/ConradKurth/forecasting/backend/pkg/id"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
)

var (
	ErrBatchAlreadyClosed = errors.New("batch already closed")
)

const insertLocationsBatch = `-- name: InsertLocationsBatch :batchexec
INSERT INTO locations (id, integration_id, external_id, name, address, country, province, is_active, created_at, updated_at) 
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
ON CONFLICT (external_id)
DO UPDATE SET
    name = EXCLUDED.name,
    address = EXCLUDED.address,
    country = EXCLUDED.country,
    province = EXCLUDED.province,
    is_active = EXCLUDED.is_active,
    updated_at = EXCLUDED.updated_at
`

type InsertLocationsBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type InsertLocationsBatchParams struct {
	ID            id.ID[id.Location]            `json:"id"`
	IntegrationID id.ID[id.PlatformIntegration] `json:"integration_id"`
	ExternalID    pgtype.Text                   `json:"external_id"`
	Name          string                        `json:"name"`
	Address       pgtype.Text                   `json:"address"`
	Country       pgtype.Text                   `json:"country"`
	Province      pgtype.Text                   `json:"province"`
	IsActive      pgtype.Bool                   `json:"is_active"`
	CreatedAt     pgtype.Timestamp              `json:"created_at"`
	UpdatedAt     pgtype.Timestamp              `json:"updated_at"`
}

func (q *Queries) InsertLocationsBatch(ctx context.Context, arg []InsertLocationsBatchParams) *InsertLocationsBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ID,
			a.IntegrationID,
			a.ExternalID,
			a.Name,
			a.Address,
			a.Country,
			a.Province,
			a.IsActive,
			a.CreatedAt,
			a.UpdatedAt,
		}
		batch.Queue(insertLocationsBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &InsertLocationsBatchBatchResults{br, len(arg), false}
}

func (b *InsertLocationsBatchBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *InsertLocationsBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const insertProductVariantsBatch = `-- name: InsertProductVariantsBatch :batchexec
INSERT INTO product_variants (id, product_id, external_id, sku, price, inventory_item_id, created_at, updated_at) 
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT (external_id)
DO UPDATE SET
    sku = EXCLUDED.sku,
    price = EXCLUDED.price,
    inventory_item_id = EXCLUDED.inventory_item_id,
    updated_at = EXCLUDED.updated_at
`

type InsertProductVariantsBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type InsertProductVariantsBatchParams struct {
	ID              id.ID[id.ProductVariant] `json:"id"`
	ProductID       id.ID[id.Product]        `json:"product_id"`
	ExternalID      pgtype.Text              `json:"external_id"`
	Sku             pgtype.Text              `json:"sku"`
	Price           pgtype.Numeric           `json:"price"`
	InventoryItemID pgtype.Text              `json:"inventory_item_id"`
	CreatedAt       pgtype.Timestamp         `json:"created_at"`
	UpdatedAt       pgtype.Timestamp         `json:"updated_at"`
}

func (q *Queries) InsertProductVariantsBatch(ctx context.Context, arg []InsertProductVariantsBatchParams) *InsertProductVariantsBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ID,
			a.ProductID,
			a.ExternalID,
			a.Sku,
			a.Price,
			a.InventoryItemID,
			a.CreatedAt,
			a.UpdatedAt,
		}
		batch.Queue(insertProductVariantsBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &InsertProductVariantsBatchBatchResults{br, len(arg), false}
}

func (b *InsertProductVariantsBatchBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *InsertProductVariantsBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}

const insertProductsBatch = `-- name: InsertProductsBatch :batchexec
INSERT INTO products (id, integration_id, external_id, title, handle, product_type, status, created_at, updated_at) 
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
ON CONFLICT (integration_id, handle)
DO UPDATE SET
    external_id = EXCLUDED.external_id,
    title = EXCLUDED.title,
    product_type = EXCLUDED.product_type,
    status = EXCLUDED.status,
    updated_at = EXCLUDED.updated_at
`

type InsertProductsBatchBatchResults struct {
	br     pgx.BatchResults
	tot    int
	closed bool
}

type InsertProductsBatchParams struct {
	ID            id.ID[id.Product]             `json:"id"`
	IntegrationID id.ID[id.PlatformIntegration] `json:"integration_id"`
	ExternalID    pgtype.Text                   `json:"external_id"`
	Title         string                        `json:"title"`
	Handle        string                        `json:"handle"`
	ProductType   pgtype.Text                   `json:"product_type"`
	Status        ProductStatus                 `json:"status"`
	CreatedAt     pgtype.Timestamp              `json:"created_at"`
	UpdatedAt     pgtype.Timestamp              `json:"updated_at"`
}

func (q *Queries) InsertProductsBatch(ctx context.Context, arg []InsertProductsBatchParams) *InsertProductsBatchBatchResults {
	batch := &pgx.Batch{}
	for _, a := range arg {
		vals := []interface{}{
			a.ID,
			a.IntegrationID,
			a.ExternalID,
			a.Title,
			a.Handle,
			a.ProductType,
			a.Status,
			a.CreatedAt,
			a.UpdatedAt,
		}
		batch.Queue(insertProductsBatch, vals...)
	}
	br := q.db.SendBatch(ctx, batch)
	return &InsertProductsBatchBatchResults{br, len(arg), false}
}

func (b *InsertProductsBatchBatchResults) Exec(f func(int, error)) {
	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
}

func (b *InsertProductsBatchBatchResults) Close() error {
	b.closed = true
	return b.br.Close()
}
