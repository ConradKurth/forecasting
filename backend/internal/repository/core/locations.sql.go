// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: locations.sql

package core

import (
	"context"

	"github.com/ConradKurth/forecasting/backend/pkg/id"
	"github.com/jackc/pgx/v5/pgtype"
)

const createLocation = `-- name: CreateLocation :one
INSERT INTO locations (id, integration_id, external_id, name, address, country, province, is_active, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW(), NOW())
RETURNING id, integration_id, external_id, name, address, country, province, is_active, created_at, updated_at
`

type CreateLocationParams struct {
	ID            id.ID[id.Location]            `json:"id"`
	IntegrationID id.ID[id.PlatformIntegration] `json:"integration_id"`
	ExternalID    pgtype.Text                   `json:"external_id"`
	Name          string                        `json:"name"`
	Address       pgtype.Text                   `json:"address"`
	Country       pgtype.Text                   `json:"country"`
	Province      pgtype.Text                   `json:"province"`
	IsActive      pgtype.Bool                   `json:"is_active"`
}

func (q *Queries) CreateLocation(ctx context.Context, arg CreateLocationParams) (Location, error) {
	row := q.db.QueryRow(ctx, createLocation,
		arg.ID,
		arg.IntegrationID,
		arg.ExternalID,
		arg.Name,
		arg.Address,
		arg.Country,
		arg.Province,
		arg.IsActive,
	)
	var i Location
	err := row.Scan(
		&i.ID,
		&i.IntegrationID,
		&i.ExternalID,
		&i.Name,
		&i.Address,
		&i.Country,
		&i.Province,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLocationByExternalID = `-- name: GetLocationByExternalID :one
SELECT id, integration_id, external_id, name, address, country, province, is_active, created_at, updated_at
FROM locations
WHERE integration_id = $1 AND external_id = $2
`

type GetLocationByExternalIDParams struct {
	IntegrationID id.ID[id.PlatformIntegration] `json:"integration_id"`
	ExternalID    pgtype.Text                   `json:"external_id"`
}

func (q *Queries) GetLocationByExternalID(ctx context.Context, arg GetLocationByExternalIDParams) (Location, error) {
	row := q.db.QueryRow(ctx, getLocationByExternalID, arg.IntegrationID, arg.ExternalID)
	var i Location
	err := row.Scan(
		&i.ID,
		&i.IntegrationID,
		&i.ExternalID,
		&i.Name,
		&i.Address,
		&i.Country,
		&i.Province,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLocationByID = `-- name: GetLocationByID :one
SELECT id, integration_id, external_id, name, address, country, province, is_active, created_at, updated_at
FROM locations
WHERE id = $1
`

func (q *Queries) GetLocationByID(ctx context.Context, argID id.ID[id.Location]) (Location, error) {
	row := q.db.QueryRow(ctx, getLocationByID, argID)
	var i Location
	err := row.Scan(
		&i.ID,
		&i.IntegrationID,
		&i.ExternalID,
		&i.Name,
		&i.Address,
		&i.Country,
		&i.Province,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLocationsByIntegrationID = `-- name: GetLocationsByIntegrationID :many
SELECT id, integration_id, external_id, name, address, country, province, is_active, created_at, updated_at
FROM locations
WHERE integration_id = $1 AND is_active = true
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetLocationsByIntegrationIDParams struct {
	IntegrationID id.ID[id.PlatformIntegration] `json:"integration_id"`
	Limit         int32                         `json:"limit"`
	Offset        int32                         `json:"offset"`
}

func (q *Queries) GetLocationsByIntegrationID(ctx context.Context, arg GetLocationsByIntegrationIDParams) ([]Location, error) {
	rows, err := q.db.Query(ctx, getLocationsByIntegrationID, arg.IntegrationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Location{}
	for rows.Next() {
		var i Location
		if err := rows.Scan(
			&i.ID,
			&i.IntegrationID,
			&i.ExternalID,
			&i.Name,
			&i.Address,
			&i.Country,
			&i.Province,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertLocation = `-- name: UpsertLocation :one
INSERT INTO locations (id, integration_id, external_id, name, address, country, province, is_active, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW(), NOW())
ON CONFLICT (integration_id, external_id)
DO UPDATE SET
    name = EXCLUDED.name,
    address = EXCLUDED.address,
    country = EXCLUDED.country,
    province = EXCLUDED.province,
    is_active = EXCLUDED.is_active,
    updated_at = NOW()
RETURNING id, integration_id, external_id, name, address, country, province, is_active, created_at, updated_at
`

type UpsertLocationParams struct {
	ID            id.ID[id.Location]            `json:"id"`
	IntegrationID id.ID[id.PlatformIntegration] `json:"integration_id"`
	ExternalID    pgtype.Text                   `json:"external_id"`
	Name          string                        `json:"name"`
	Address       pgtype.Text                   `json:"address"`
	Country       pgtype.Text                   `json:"country"`
	Province      pgtype.Text                   `json:"province"`
	IsActive      pgtype.Bool                   `json:"is_active"`
}

func (q *Queries) UpsertLocation(ctx context.Context, arg UpsertLocationParams) (Location, error) {
	row := q.db.QueryRow(ctx, upsertLocation,
		arg.ID,
		arg.IntegrationID,
		arg.ExternalID,
		arg.Name,
		arg.Address,
		arg.Country,
		arg.Province,
		arg.IsActive,
	)
	var i Location
	err := row.Scan(
		&i.ID,
		&i.IntegrationID,
		&i.ExternalID,
		&i.Name,
		&i.Address,
		&i.Country,
		&i.Province,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
