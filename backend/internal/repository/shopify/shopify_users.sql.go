// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: shopify_users.sql

package shopify

import (
	"context"

	"github.com/ConradKurth/forecasting/backend/internal/crypto"
	"github.com/ConradKurth/forecasting/backend/pkg/id"
	"github.com/jackc/pgx/v5/pgtype"
)

const createOrUpdateShopifyUser = `-- name: CreateOrUpdateShopifyUser :one
INSERT INTO shopify_users (id, user_id, shopify_store_id, access_token, scope, expires_at, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
ON CONFLICT (user_id, shopify_store_id)
DO UPDATE SET
    access_token = EXCLUDED.access_token,
    scope = EXCLUDED.scope,
    expires_at = EXCLUDED.expires_at,
    updated_at = NOW()
RETURNING id, user_id, shopify_store_id, access_token, scope, expires_at, created_at, updated_at
`

type CreateOrUpdateShopifyUserParams struct {
	ID             id.ID[id.ShopifyUser]  `json:"id"`
	UserID         id.ID[id.User]         `json:"user_id"`
	ShopifyStoreID id.ID[id.ShopifyStore] `json:"shopify_store_id"`
	AccessToken    crypto.EncryptedSecret `json:"access_token"`
	Scope          string                 `json:"scope"`
	ExpiresAt      pgtype.Timestamp       `json:"expires_at"`
}

func (q *Queries) CreateOrUpdateShopifyUser(ctx context.Context, arg CreateOrUpdateShopifyUserParams) (ShopifyUser, error) {
	row := q.db.QueryRow(ctx, createOrUpdateShopifyUser,
		arg.ID,
		arg.UserID,
		arg.ShopifyStoreID,
		arg.AccessToken,
		arg.Scope,
		arg.ExpiresAt,
	)
	var i ShopifyUser
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ShopifyStoreID,
		&i.AccessToken,
		&i.Scope,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createShopifyUser = `-- name: CreateShopifyUser :one
INSERT INTO shopify_users (id, user_id, shopify_store_id, access_token, scope, expires_at, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
RETURNING id, user_id, shopify_store_id, access_token, scope, expires_at, created_at, updated_at
`

type CreateShopifyUserParams struct {
	ID             id.ID[id.ShopifyUser]  `json:"id"`
	UserID         id.ID[id.User]         `json:"user_id"`
	ShopifyStoreID id.ID[id.ShopifyStore] `json:"shopify_store_id"`
	AccessToken    crypto.EncryptedSecret `json:"access_token"`
	Scope          string                 `json:"scope"`
	ExpiresAt      pgtype.Timestamp       `json:"expires_at"`
}

func (q *Queries) CreateShopifyUser(ctx context.Context, arg CreateShopifyUserParams) (ShopifyUser, error) {
	row := q.db.QueryRow(ctx, createShopifyUser,
		arg.ID,
		arg.UserID,
		arg.ShopifyStoreID,
		arg.AccessToken,
		arg.Scope,
		arg.ExpiresAt,
	)
	var i ShopifyUser
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ShopifyStoreID,
		&i.AccessToken,
		&i.Scope,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getShopifyUserByUserAndDomain = `-- name: GetShopifyUserByUserAndDomain :one
SELECT su.id, su.user_id, su.shopify_store_id, su.access_token, su.scope, su.expires_at, su.created_at, su.updated_at
FROM shopify_users su
JOIN shopify_store ss ON su.shopify_store_id = ss.id
WHERE su.user_id = $1 AND ss.shop_domain = $2
`

type GetShopifyUserByUserAndDomainParams struct {
	UserID     id.ID[id.User] `json:"user_id"`
	ShopDomain string         `json:"shop_domain"`
}

func (q *Queries) GetShopifyUserByUserAndDomain(ctx context.Context, arg GetShopifyUserByUserAndDomainParams) (ShopifyUser, error) {
	row := q.db.QueryRow(ctx, getShopifyUserByUserAndDomain, arg.UserID, arg.ShopDomain)
	var i ShopifyUser
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ShopifyStoreID,
		&i.AccessToken,
		&i.Scope,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getShopifyUserByUserAndStore = `-- name: GetShopifyUserByUserAndStore :one
SELECT id, user_id, shopify_store_id, access_token, scope, expires_at, created_at, updated_at
FROM shopify_users
WHERE user_id = $1 AND shopify_store_id = $2
`

type GetShopifyUserByUserAndStoreParams struct {
	UserID         id.ID[id.User]         `json:"user_id"`
	ShopifyStoreID id.ID[id.ShopifyStore] `json:"shopify_store_id"`
}

func (q *Queries) GetShopifyUserByUserAndStore(ctx context.Context, arg GetShopifyUserByUserAndStoreParams) (ShopifyUser, error) {
	row := q.db.QueryRow(ctx, getShopifyUserByUserAndStore, arg.UserID, arg.ShopifyStoreID)
	var i ShopifyUser
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ShopifyStoreID,
		&i.AccessToken,
		&i.Scope,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getShopifyUsersByStore = `-- name: GetShopifyUsersByStore :many
SELECT id, user_id, shopify_store_id, access_token, scope, expires_at, created_at, updated_at
FROM shopify_users
WHERE shopify_store_id = $1
`

func (q *Queries) GetShopifyUsersByStore(ctx context.Context, shopifyStoreID id.ID[id.ShopifyStore]) ([]ShopifyUser, error) {
	rows, err := q.db.Query(ctx, getShopifyUsersByStore, shopifyStoreID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ShopifyUser{}
	for rows.Next() {
		var i ShopifyUser
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ShopifyStoreID,
			&i.AccessToken,
			&i.Scope,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShopifyUsersByUser = `-- name: GetShopifyUsersByUser :many
SELECT id, user_id, shopify_store_id, access_token, scope, expires_at, created_at, updated_at
FROM shopify_users
WHERE user_id = $1
`

func (q *Queries) GetShopifyUsersByUser(ctx context.Context, userID id.ID[id.User]) ([]ShopifyUser, error) {
	rows, err := q.db.Query(ctx, getShopifyUsersByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ShopifyUser{}
	for rows.Next() {
		var i ShopifyUser
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ShopifyStoreID,
			&i.AccessToken,
			&i.Scope,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateShopifyUserToken = `-- name: UpdateShopifyUserToken :one
UPDATE shopify_users
SET access_token = $3, scope = $4, expires_at = $5, updated_at = NOW()
WHERE user_id = $1 AND shopify_store_id = $2
RETURNING id, user_id, shopify_store_id, access_token, scope, expires_at, created_at, updated_at
`

type UpdateShopifyUserTokenParams struct {
	UserID         id.ID[id.User]         `json:"user_id"`
	ShopifyStoreID id.ID[id.ShopifyStore] `json:"shopify_store_id"`
	AccessToken    crypto.EncryptedSecret `json:"access_token"`
	Scope          string                 `json:"scope"`
	ExpiresAt      pgtype.Timestamp       `json:"expires_at"`
}

func (q *Queries) UpdateShopifyUserToken(ctx context.Context, arg UpdateShopifyUserTokenParams) (ShopifyUser, error) {
	row := q.db.QueryRow(ctx, updateShopifyUserToken,
		arg.UserID,
		arg.ShopifyStoreID,
		arg.AccessToken,
		arg.Scope,
		arg.ExpiresAt,
	)
	var i ShopifyUser
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ShopifyStoreID,
		&i.AccessToken,
		&i.Scope,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
